const fs = require("fs");
const path = require("path");
const { getScrapePath } = require('./config');

// getScrapePath() is now imported from config.js and always returns data/scrape

/**
 * ScrapeReader - Navigation through JSON files in the scrape folder
 * Similar to LibraryReader but for JSON files generated by scrapers
 */
class ScrapeReader {
  constructor() {
    // Use library-specific path
    this.updateScrapePath();
    this.items = [];
    this.currentIndex = -1;
  }

  /**
   * Update scrape path based on current library path
   */
  updateScrapePath() {
    this.scrapePath = getScrapePath();

    // Create folder if it doesn't exist
    if (!fs.existsSync(this.scrapePath)) {
      fs.mkdirSync(this.scrapePath, { recursive: true });
    }
  }

  /**
   * Loads all JSON files from the scrape folder
   */
  loadScrapeItems() {
    // Update path in case library changed
    this.updateScrapePath();

    this.items = [];
    this.currentIndex = -1;

    if (!fs.existsSync(this.scrapePath)) {
      return;
    }

    const files = fs.readdirSync(this.scrapePath);

    // Filter only .json files
    const jsonFiles = files.filter(f => f.endsWith(".json"));

    this.items = jsonFiles.map(filename => ({
      id: path.basename(filename, ".json"),
      jsonPath: path.join(this.scrapePath, filename)
    }));

    // Sort by file name (ID)
    this.items.sort((a, b) => a.id.localeCompare(b.id));

    if (this.items.length > 0) {
      this.currentIndex = 0;
    }
  }

  /**
   * Returns the current item (with loaded data)
   * If file is corrupted, returns null without crashing
   */
  getCurrent() {
    if (this.currentIndex < 0 || this.currentIndex >= this.items.length) {
      return null;
    }

    const item = this.items[this.currentIndex];

    try {
      const jsonData = fs.readFileSync(item.jsonPath, "utf8");
      const parsed = JSON.parse(jsonData);

      return {
        id: item.id,
        jsonPath: item.jsonPath,
        ...parsed
      };
    } catch (err) {
      console.error(`Skipping corrupted JSON ${item.jsonPath}:`, err.message);
      return null;
    }
  }

  /**
   * Moves to next valid item (skips corrupted files)
   */
  getNext() {
    if (this.items.length === 0) return null;

    const startIndex = this.currentIndex;
    let attempts = 0;

    // Try until it finds a valid file or has checked all
    do {
      this.currentIndex = (this.currentIndex + 1) % this.items.length;
      attempts++;

      const result = this.getCurrent();
      if (result !== null) {
        return result;
      }

      // If we've done a full loop, all files are corrupted
      if (attempts >= this.items.length) {
        console.error("All JSON files are corrupted");
        return null;
      }
    } while (this.currentIndex !== startIndex);

    return null;
  }

  /**
   * Moves to previous valid item (skips corrupted files)
   */
  getPrevious() {
    if (this.items.length === 0) return null;

    const startIndex = this.currentIndex;
    let attempts = 0;

    // Try until it finds a valid file or has checked all
    do {
      this.currentIndex = (this.currentIndex - 1 + this.items.length) % this.items.length;
      attempts++;

      const result = this.getCurrent();
      if (result !== null) {
        return result;
      }

      // If we've done a full loop, all files are corrupted
      if (attempts >= this.items.length) {
        console.error("All JSON files are corrupted");
        return null;
      }
    } while (this.currentIndex !== startIndex);

    return null;
  }

  /**
   * Reloads the current item
   */
  reloadCurrent() {
    return this.getCurrent();
  }

  /**
   * Deletes the current JSON file
   */
  deleteCurrent() {
    if (this.currentIndex < 0 || this.currentIndex >= this.items.length) {
      return { ok: false, error: "No item selected" };
    }

    const item = this.items[this.currentIndex];

    try {
      fs.unlinkSync(item.jsonPath);

      // Remove from array
      this.items.splice(this.currentIndex, 1);

      // Adjust the index
      if (this.items.length === 0) {
        this.currentIndex = -1;
      } else if (this.currentIndex >= this.items.length) {
        this.currentIndex = this.items.length - 1;
      }

      return { ok: true };
    } catch (err) {
      return { ok: false, error: err.message };
    }
  }

  /**
   * Counts available JSON files
   */
  getCount() {
    return this.items.length;
  }

  /**
   * Gets the current index
   */
  getCurrentIndex() {
    return this.currentIndex;
  }
}

module.exports = ScrapeReader;
